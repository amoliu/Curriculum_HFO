#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Tue November 30
Object-Oriented Curriculum Generation that uses a biased random walk to "prune" tasks.

A very big Curriculum should be generated by using svetlik's proposal, then the actual
task list is defined by executing a biased random walk from the target task, according to the transfer potential between
each task and the target.
"""

from curriculum.generatedsourceoocurriculum import GeneratedSourceOOCurriculum

import OOUtil
import random



class PrunedGeneratedCurriculum(GeneratedSourceOOCurriculum):
    repetitions = None
    randomSteps = None

    def __init__(self, seed=12345, agent=None):


        super(PrunedGeneratedCurriculum, self).__init__(seed=seed, agent=agent)



    def generate_curriculum(self, target_task, sourceFolder, workFolder, thresholdTask=None):
        # Defines default parameter to each domain
        if thresholdTask is None:
            if target_task.get_domain_task() == 'HFOTask':
                thresholdTask = 0.5
                repGeneration = 20
                self.repetitions = 3
                self.randomSteps = 3
            elif target_task.get_domain_task() == 'GridWorldTask':
                thresholdTask = 0.5  # 40
                repGeneration = 2
                self.repetitions = 2
                self.randomSteps = 2
                self.agent.alpha = 0.95  # Grid
        super(PrunedGeneratedCurriculum, self).generate_curriculum(target_task=target_task, sourceFolder=sourceFolder,
                                                                  workFolder=workFolder, thresholdTask=thresholdTask,repGeneration=repGeneration)

    def generate_curriculum_from_tasks(self, target_task, taskList, thresholdTask=None):
        # Defines default parameter to each domain
        if thresholdTask is None:
            if target_task.get_domain_task() == 'HFOTask':
                thresholdTask = 0.5
                repGeneration = 10
                self.repetitions = 3
                self.randomSteps = 3
            elif target_task.get_domain_task() == 'GridWorldTask':
                thresholdTask = 0.5
                self.repetitions = 2
                self.randomSteps = 2
                self.agent.alpha = 0.95  # Grid
        super(PrunedGeneratedCurriculum, self).generate_curriculum_from_tasks(target_task=target_task, taskList=taskList,
                                                                             thresholdTask=thresholdTask)

    def build_task_list(self, setOfTasks, target_task):
        """Defines one possible order for presenting the tasks"""
        state = random.getstate()
        random.seed(self.seed)

        repetitions = self.repetitions
        randomSteps = self.randomSteps

        #Defines the next tasks randomly

        self.taskList = []

        import copy

        print("--- Task List:")


        currentTask = target_task
        #Performs a biased random Walking starting from the target task
        for y in range(repetitions):
            currentTask = target_task
            for i in range(randomSteps):
                #Get set of possible next tasks
                setForSorting = set()
                #par = self.taskGraph.list_parents(currentTask)
                #setForSorting.update(par)
                setForSorting.update(self.taskGraph.list_children(currentTask))

                if setForSorting == set():
                    continue

                #Calculate the transfer potential between the tasks and choose the next one according to the value
                sum = 0
                potValues = []
                listForSorting = list(setForSorting)
                for task in listForSorting:
                    pot = self.transfer_potential(task,currentTask,self.taskList)
                    sum = sum + pot
                    potValues.append(pot)
                #Normalize all values to probabilities
                potValues = [i / sum for i in potValues]

                randNum = random.uniform(0,1)
                index = 0
                sumChoice = potValues[0]

                while randNum > sumChoice:
                    index += 1
                    sumChoice += potValues[index]
                t = listForSorting[index]



                #Performs a biased random step
                #t = random.choice(list(setForSorting)) uncomment this for default random walk
                currentTask = t
                # making sure the task wasn't selected yet
                if not t in self.taskList and t != target_task:
                    #List of task that must come after t
                    afterTasks = self.taskGraph.list_parents(t)

                    apIndex = len(self.taskList)
                    #Find appropriate index for t
                    for parTask in afterTasks:
                        if parTask in self.taskList:
                            apIndex = min(apIndex,self.taskList.index(parTask))
                    #Get task from list of original tasks
                    origTask = next(x for x in setOfTasks if x.name == t.name)
                    self.taskList.insert(apIndex,origTask)
                    print(origTask.name)

        #After all tasks have been selected by the random walk, it is time to include the target
        self.taskList.append(target_task)
        print("------")

        self.taskList.append(target_task)

        random.setstate(state)












